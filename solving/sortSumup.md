## 排序算法总结

### 冒泡
  没啥可说的
  
### 选择排序

  「选择最小的排序」。选最小的放第一个 然后递归 1 ~ size的长度。
   可以看出来复杂度还是 O(n^2)的 没啥意义 是对冒泡的一个优化，降低了没有必要的交换位置
   
### 插入排序
   
   插入的思想是，将无序序列插入到有序序列之中，这样左侧的空序列一开始是有序的，我们只要循环右侧，分别插入到左侧就好。 这个本质也会有n^2 的复杂度，最坏情况下。最好情况下（本身有序）则只要n次但这个也没有意义
   
## 总结
 
  以上三种 是所谓的简单排序，基本思想还是操作序列进行比较，因此跟quick sort merge sort 还是差别较大。 虽然选择和插入在代码中 还是可以写成递归的形式，然而这个并没有使用到分治的思想。
  
  结合一下分治的思想，再来看看相应的「高级方法」
  
### 快速排序

  我总会因为名字记不起策略，然而作为最广泛的排序方法，快排是第一个分治方案的结果，因此想到的第一个分治的排序方案就应该是快排。它的想法是 对一个 数组 根据一个pivot 分为左侧小 右侧大的部分（像不像中根序的二叉树）然后递归左右两个子序列。
  
  写法上有一个trick。
  
  由于我们默认用第一个元素作为pivot 那么第一个位置就是空的，可以用作交换，
  因此左右双指针， 左边有空位那么从右边开始，找到小的 放空位，然后从左边开始，找到大的放空位，知道 i==j 这个时候 i j 都指向空位，那么key 放下去 递归。
   
  手写一下
  
  手写完成，注意循环条件， 负责度 n^2 当且仅当是逆序的时候最大 每次都要比较length
  其实不是逆序，而是 划分出来的区间是 n-1 和 1 的时候。
  最好则是每次划分都是n/2 这样就是一个二叉树 那么它自然就是 nlogn  平均也是这个。 因此它是一个不稳定排序
  对了 百科上说这也是对冒泡的改进 而不是纯粹的归并因此可以看出在最坏情况还是只有n 2 的复杂度
  接下来看纯粹的分治算法 归并
  
### 归并排序
   
   思想是 对 有序序列进行归并，降低比较次数，那么一开始一个无序序列是怎么有序的呢，每个元素是单独有序的。 然后每次将它与它下一个元素进行归并
   做法是申请空间，然后依次拷贝。 两个子序列。 怎么写成递归呢
   这里 设计函数参数时候 就需要 设计成 主要merge 是 长度 和 起始index 这里可以看到每次归并必然是按两倍长度扩张。 这是最典型的分治算法，因此它复杂度是 nlogn 的并且是稳定排序。
   
### 二分查找
最后，来看看二分查找，这个只是训练一下数组边界能力。这里我们试一下
ß
试完 这里注意 middle 是 hight + low  >> 1 这样 否则就是length /2 + low 这样才能对齐坐标。
另外这里可以非递归的，是通过 i ， j 两个指针，每次检查完 修改 i ，j 然后while 就好

    
  